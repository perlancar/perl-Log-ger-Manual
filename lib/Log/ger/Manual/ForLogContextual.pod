package Log::ger::Manual::ForLogContextual;

# DATE
# VERSION

1;
# ABSTRACT: Log::ger for Log::Contextual users

=pod

=head1 WHY LOG::CONTEXTUAL

In my opinion, just about the only good thing about L<Log::Contextual> is that
it provides block style by default, if that's what you like:

 log_trace { "foo bar " . some_heavy_calculation() };

The block will not be executed if the log level is higher than C<trace>,
although C<log_trace()> itself is still called.

Log::Contextual provides interface for L<Log::Log4perl>, L<Log::Dispatch>,
L<Log::Dispatchouli>, and some others. But this is not unique to
Log::Contextual; other libraries like L<Log::Any> or L<Log::ger> can also use
various backends.


=head1 WHY LOG::GER OVER LOG::CONTEXTUAL

Log::Contextual does not yet encourage separation of logging consumer and
producer. You have to (or, the documentation encourages you to) set up the
backend in the same place as the logging.

Log::ger is much faster and has a significantly smaller startup overhead.
Although Log::Contextual's documentation mentions being "efficient" (in terms of
avoiding executing the block if level is not active), Log::Contextual is not
efficient in that it adds I<considerable> logging overhead. See benchmark in
L<Bencher::Scenarios::LogGer>. I think you are better off using Log4perl
directly than through Log::Contextual.

Log::ger also provides block style if you want (see L<Log::ger::Format::Block>).


=head1 FAQ
